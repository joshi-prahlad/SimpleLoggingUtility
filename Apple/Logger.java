package Apple;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import Apple.Logger.DMLogLevel;

/*
 * Logger is the main class which is implemented as a singleton and has DMLog method.
 * In its constructor it sets up the FileWriter to the log file (which is created in 
 * the current directory with the name "errorLog"). Also, a thread pool of DM_NUM_CORES 
 * threads is created, each with a associated thread safe queue and the same FileWriter instance.
 * Each LoggerThread is 
 * responsible for handling one queue. It polls the queue for a message and stores the log
 * message in its cache and flushes the cache to console/log file when either the cache is
 * full or we see a DMLogError message. When a thread calls DMLog method for the first time
 * we create a mapping from that thread to one of the work queues and all the log messages 
 * generated by that thread is inserted in the associated queue. So all the message generated
 * by one thread always ends up in the same queue while a queue might have messages 
 * generated from multiple threads. Caching log messages avoids writing to disks too frequently
 * and having a thread pool allows multiple threads to use logging facility concurrently.
 * FileWriter is appropriately protected from multiple thread access with synchronized keyword
 * and ConcurrentLinkedQueue is used to allow multiple threads to safely insert in the 
 * message queue.
 * 
 * To run tests
 * 
 * java 
 * 
 */
public class Logger {

	private final String logFilePath = "errorLog";
	private FileWriter fileWriter;
	Map<Long, Queue<Message>> threadIdToQueue;
	private static final Logger logger = new Logger();
	private int currentThread = 0;
	private LoggerThread[] loggerThreads;

	private Logger() {
		fileWriter = new FileWriter(logFilePath,
				CofigurationConstants.LOG_TO_FILE,
				CofigurationConstants.LOG_TO_CONSOLE);
		loggerThreads = new LoggerThread[CofigurationConstants.DM_NUM_CORES];
		for (int i = 0; i < loggerThreads.length; ++i) {
			loggerThreads[i] = new LoggerThread(fileWriter,
					new ConcurrentLinkedQueue<Message>());
			Thread thread = new Thread(loggerThreads[i]);
			thread.setDaemon(true);
			thread.start();
		}
		threadIdToQueue = new HashMap<>();
	}

	public enum DMLogLevel {
		DM_LOG_ERROR("<DM_LOG_ERROR>"), DM_LOG_WARNING("<DM_LOG_WARNING>"), DM_LOG_TRACE(
				"<DM_LOG_TRACE>"), DM_LOG_INFO("<DM_LOG_INFO>");

		private final String value;

		DMLogLevel(String value) {
			this.value = value;
		}

		@Override
		public String toString() {
			return this.value;
		}
	};

	public static void DMLog(DMLogLevel level, final String format,
			Object... args) {
		logger.helper(level, format, args);
	}

	public static void stop() {
		logger.close();
	}

	void close() {
		fileWriter.close();
	}

	private void helper(DMLogLevel level, final String format, Object[] args) {
		String message = String.format("%-16s:", level)
				+ String.format(format, args);
		Queue<Message> queue = null;
		synchronized (this) {
			queue = threadIdToQueue.get(Thread.currentThread().getId());
			if (queue == null) {
				queue = loggerThreads[currentThread
						% CofigurationConstants.DM_NUM_CORES].getQueue();
				++currentThread;
				threadIdToQueue.put(Thread.currentThread().getId(), queue);
			}
		}
		queue.add(new Message(message, level));
	}
}

class LoggerThread implements Runnable {
	private final FileWriter writer;

	private final char[] messageCache;
	private final int messageCacheSize = 1000000;
	private int writeIndex = 0;
	private final ConcurrentLinkedQueue<Message> messageQueue;

	LoggerThread(FileWriter writer, ConcurrentLinkedQueue<Message> messageQueue) {
		this.writer = writer;
		messageCache = new char[messageCacheSize];
		this.messageQueue = messageQueue;
	}

	public Queue<Message> getQueue() {
		return messageQueue;
	}

	public void run() {
		while (true) {
			Message currentEl = null;
			if (!messageQueue.isEmpty()) {
				currentEl = messageQueue.poll();
			}
			if (currentEl == null) {
				continue;
			}
			for (char c : currentEl.toString().toCharArray()) {
				messageCache[writeIndex++] = c;
			}
			messageCache[writeIndex++] = '\n';
			flushCacheIfFull();
			if (currentEl.getLevel() == Logger.DMLogLevel.DM_LOG_ERROR) {
				flushCache();
			}
		}
	}

	private void flushCacheIfFull() {
		if (this.writeIndex + 1000 > messageCacheSize) {
			flushCache();
		}
	}

	private void flushCache() {
		writer.write(messageCache, writeIndex);
		writeIndex = 0;
	}
}

class Message {
	private final String value;
	private final Logger.DMLogLevel level;

	Message(String value, Logger.DMLogLevel level) {
		this.value = value;
		this.level = level;
	}

	public String toString() {
		return value;
	}

	public DMLogLevel getLevel() {
		return this.level;
	}
}

class FileWriter {

	private String filePath;
	private PrintWriter printWriter;
	private final boolean logToConsole;
	private final boolean logToFile;

	public FileWriter(final String path, boolean logToFile, boolean logToConsole) {
		this.logToFile = logToFile;
		if (logToFile) {
			this.filePath = path;
			try {
				printWriter = new PrintWriter(new File(this.filePath));
			} catch (IOException e) {
				System.err.println("Can't open log file " + this.filePath);
				e.printStackTrace();
				System.exit(-1);
			}
		}
		this.logToConsole = logToConsole;
	}

	public void close() {
		if (printWriter != null) {
			printWriter.flush();
			try {
				printWriter.close();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

	public synchronized void write(char[] data, int length) {
		if (logToFile) {
			printWriter.write(data, 0, length);
			printWriter.flush();
		}
		if (logToConsole) {
			System.out.print(Arrays.copyOfRange(data, 0, length));
		}
	}
}
